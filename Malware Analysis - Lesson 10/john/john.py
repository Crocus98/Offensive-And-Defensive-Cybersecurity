#creat the firt.bin file with the unpacked code by running the file until the unpacked code function call (break point at b *0x804928a)
#and there use the command => dump binary memory first.bin $eax ($eax + (4*0x53))

#Run this python script to obtain the patched unpacked file (partially patched). (It has to be adjusted since it does not work)
"""
from pwn import *

f = open("./john","rb")
old = f.read()
f.close()
f = open("./first.bin","rb")
first = f.read()
f.close()
base_offset = 0x170e #offset between main and binary in order to keep things aligned
new = old[:base_offset] + first + old[base_offset + (0x53*4):]
f = open("john_patched", "wb")
f.write(new)
f.close()
"""

#This script is useful to create a binary with the assembly code in order to read it outside of gdb if necessary.
"""from pwn import *
f = open("./first.bin","rb")
content = f.read()
f.close()
print(disasm(content))"""

#address to stop before the if that check the flag 0x8049821


#This is the code to patch the binary (this works even better)
"""
import sys
from pwn import u32, p32

#To make this work put as parameters the filename (./john), the address (0x0804970e) and the size (0x53)
#If necessary it can be done multiple times
#Once everything is decoded it's just a reversing challenge

if len(sys.argv) < 4:
    print("usage : %s <inputfile> <address> <size>" % sys.argv[0])
    exit(0)

filepath = sys.argv[1]
address = int(sys.argv[2], 16)
size = int(sys.argv[3], 16)

BEG_BIN = 0x08048000 #begin of file
KEY = [0x04030201, 0x40302010, 0x42303042, 0x44414544, 0xffffffff]
ff = open(filepath, "rb")
f = ff.read()
ff.close()

off = address - BEG_BIN
to_decode = f[off: off+(size*4)]
k = KEY[address % 5]

decode = b""
for i in range(size):
    decode += p32(u32(to_decode[i*4: (i+1)*4]) ^ k)

f = f[:off] + decode + f[off+(size*4):]

ff = open(filepath, "wb")
ff.write(f)
ff.close()
"""